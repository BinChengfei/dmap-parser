#include "dmap_parser.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>
#include <fcntl.h>
#include <assert.h>

char output[2048] = {0};
size_t outpos = 0;
char prefix[64] = {0};
static const char hexchars[] = "0123456789abcdef";

typedef struct {
	const char *name;
	const char msg[1024];
	size_t msglen;
	const char* expected;
} test;

static const test tests[] = {

/* Basic types */
{
	"8-bit unsigned integer",
	{ 0x6d, 0x73, 0x75, 0x70, 0x00, 0x00, 0x00, 0x01, 0x01 },
	9,
	"dmap.supportsupdate: 1\n"
},
{
	"8-bit signed integer",
	{ 0x61, 0x73, 0x72, 0x76, 0x00, 0x00, 0x00, 0x01, 0xce },
	9,
	"daap.songrelativevolume: -50\n"
},
{
	"16-bit unsigned integer",
	{ 0x61, 0x73, 0x79, 0x72, 0x00, 0x00, 0x00, 0x02, 0x07, 0xd0 },
	10,
	"daap.songyear: 2000\n"
},
{
	"16-bit signed integer",
	{ 0x6d, 0x73, 0x74, 0x6f, 0x00, 0x00, 0x00, 0x02, 0xf8, 0x30 },
	10,
	"dmap.utcoffset: -2000\n"
},
{
	"32-bit unsigned integer",
	{ 0x6d, 0x69, 0x69, 0x64, 0x00, 0x00, 0x00, 0x04, 0x09, 0x23, 0x25, 0xfb },
	12,
	"dmap.itemid: 153298427\n"
},
{
	"32-bit signed integer",
	{ 0x6d, 0x73, 0x74, 0x6f, 0x00, 0x00, 0x00, 0x04, 0xf6, 0xdc, 0xda, 0x05 },
	12,
	"dmap.utcoffset: -153298427\n"
},
{
	"64-bit unsigned integer",
	{
	0x6d, 0x70, 0x65, 0x72, 0x00, 0x00, 0x00, 0x08, 0xe6, 0xcc, 0x5e, 0x6f,
	0x61, 0xc9, 0x12, 0x23
	},
	16,
	"dmap.persistentid: 16630771356447347235\n"
},
{
	"64-bit signed integer",
	{
	0x6d, 0x73, 0x74, 0x6f, 0x00, 0x00, 0x00, 0x08, 0xa3, 0xfa, 0xc4, 0x95,
	0x28, 0x1e, 0xed, 0xdd
	},
	16,
	"dmap.utcoffset: -6630771356447347235\n"
},
{
	"Unmapped integer as data",
	{
	0x6d, 0x70, 0x65, 0x72, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x02, 0x03,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
	},
	24,
	"dmap.persistentid: <00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f>\n"
},
{
	"Data",
	{ 0x61, 0x65, 0x43, 0x44, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x02, 0x03 },
	12,
	"com.apple.itunes.flat-chapter-data: <00 01 02 03>\n"
},

/* Unknown types */
{
	"Unknown type: 8-bit integer",
	{ 0x74, 0x76, 0x61, 0x6c, 0x00, 0x00, 0x00, 0x01, 0x01 },
	9,
	"tval: 1\n"
},
{
	"Unknown type: dictionary",
	{
	0x64, 0x69, 0x63, 0x74, 0x00, 0x00, 0x00, 0x0c, 0x74, 0x76, 0x61, 0x6c,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01
	},
	20,
	"dict:\n"
	"  tval: 1\n"
},

/* Parsing errors */
{
	"Incomplete fourchar",
	{ 0x64, 0x69, 0x63 },
	3,
	NULL
},
{
	"No length",
	{ 0x64, 0x69, 0x63, 0x74 },
	4,
	NULL
},
{
	"Incomplete length",
	{ 0x64, 0x69, 0x63, 0x74, 0x00, 0x00, 0x00 },
	7,
	NULL
},
{
	"No data",
	{ 0x64, 0x69, 0x63, 0x74, 0x00, 0x00, 0x00, 0x02 },
	8,
	NULL
},
{
	"Invalid length",
	{ 0x64, 0x69, 0x63, 0x74, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01 },
	12,
	NULL
},
{
	"Invalid inner dictionary length",
	{
	0x61, 0x64, 0x62, 0x73, 0x00, 0x00, 0x00, 0x0c, 0x74, 0x76, 0x61, 0x6c,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01
	},
	20,
	NULL
},

/* Messages */
{
	"Login response",
	{
	0x6d, 0x6c, 0x6f, 0x67, 0x00, 0x00, 0x00, 0x18, 0x6d, 0x73, 0x74, 0x74,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x6d, 0x6c, 0x69, 0x64,
	0x00, 0x00, 0x00, 0x04, 0x3b, 0x9a, 0x7c, 0x99
	},
	32,
	"dmap.loginresponse:\n"
	"  dmap.status: 200\n"
	"  dmap.sessionid: 999980185\n"
},
{
	"Simple database item",
	{
	0x6d, 0x6c, 0x69, 0x74, 0x00, 0x00, 0x00, 0x30, 0x6d, 0x69, 0x69, 0x64,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x29, 0x6b, 0x6d, 0x69, 0x6e, 0x6d,
	0x00, 0x00, 0x00, 0x10, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74,
	0x69, 0x76, 0x65, 0x20, 0x52, 0x6f, 0x63, 0x6b, 0x6d, 0x69, 0x6d, 0x63,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x05
	},
	56,
	"dmap.listingitem:\n"
	"  dmap.itemid: 10603\n"
	"  dmap.itemname: Alternative Rock\n"
	"  dmap.itemcount: 261\n"
},
{
	"Speaker list response",
	{
	0x63, 0x61, 0x73, 0x70, 0x00, 0x00, 0x00, 0xf5, 0x6d, 0x73, 0x74, 0x74,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x6d, 0x64, 0x63, 0x6c,
	0x00, 0x00, 0x00, 0x3e, 0x6d, 0x69, 0x6e, 0x6d, 0x00, 0x00, 0x00, 0x08,
	0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x63, 0x6d, 0x76, 0x6f,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x63, 0x61, 0x76, 0x64,
	0x00, 0x00, 0x00, 0x01, 0x01, 0x6d, 0x73, 0x6d, 0x61, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x61, 0x69,
	0x61, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6d, 0x64, 0x63, 0x6c, 0x00, 0x00,
	0x00, 0x35, 0x6d, 0x69, 0x6e, 0x6d, 0x00, 0x00, 0x00, 0x08, 0x41, 0x70,
	0x70, 0x6c, 0x65, 0x20, 0x54, 0x56, 0x63, 0x6d, 0x76, 0x6f, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x6d, 0x73, 0x6d, 0x61, 0x00, 0x00,
	0x00, 0x08, 0x00, 0x00, 0x70, 0x73, 0xcb, 0xd4, 0x98, 0x72, 0x63, 0x61,
	0x69, 0x76, 0x00, 0x00, 0x00, 0x01, 0x01, 0x6d, 0x64, 0x63, 0x6c, 0x00,
	0x00, 0x00, 0x2b, 0x63, 0x6d, 0x76, 0x6f, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x64, 0x6d, 0x69, 0x6e, 0x6d, 0x00, 0x00, 0x00, 0x07, 0x42,
	0x65, 0x64, 0x72, 0x6f, 0x6f, 0x6d, 0x6d, 0x73, 0x6d, 0x61, 0x00, 0x00,
	0x00, 0x08, 0x00, 0x00, 0x44, 0xd8, 0x84, 0x6a, 0xb6, 0xfc, 0x6d, 0x64,
	0x63, 0x6c, 0x00, 0x00, 0x00, 0x2b, 0x63, 0x6d, 0x76, 0x6f, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x6d, 0x69, 0x6e, 0x6d, 0x00, 0x00,
	0x00, 0x07, 0x4b, 0x69, 0x74, 0x63, 0x68, 0x65, 0x6e, 0x6d, 0x73, 0x6d,
	0x61, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xf0, 0xb4, 0x79, 0x05, 0x66,
	0x0a
	},
	253,
	"dacp.speakers:\n"
	"  dmap.status: 200\n"
	"  dmap.dictionary:\n"
	"    dmap.itemname: Computer\n"
	"    dmcp.volume: 100\n"
	"    cavd: 1\n"
	"    dmap.machineaddress: 0\n"
	"    dacp.isactive: 1\n"
	"  dmap.dictionary:\n"
	"    dmap.itemname: Apple TV\n"
	"    dmcp.volume: 100\n"
	"    dmap.machineaddress: 123642643257458\n"
	"    caiv: 1\n"
	"  dmap.dictionary:\n"
	"    dmcp.volume: 100\n"
	"    dmap.itemname: Bedroom\n"
	"    dmap.machineaddress: 75696725210876\n"
	"  dmap.dictionary:\n"
	"    dmcp.volume: 100\n"
	"    dmap.itemname: Kitchen\n"
	"    dmap.machineaddress: 264657915176458\n"
},
{
	"Database songs response",
	{
	0x61, 0x64, 0x62, 0x73, 0x00, 0x00, 0x00, 0xb5, 0x6d, 0x73, 0x74, 0x74,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x6d, 0x75, 0x74, 0x79,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x6d, 0x74, 0x63, 0x6f, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x01, 0x6d, 0x72, 0x63, 0x6f, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x01, 0x6d, 0x6c, 0x63, 0x6c, 0x00, 0x00, 0x00,
	0x80, 0x6d, 0x6c, 0x69, 0x74, 0x00, 0x00, 0x00, 0x78, 0x6d, 0x69, 0x6b,
	0x64, 0x00, 0x00, 0x00, 0x01, 0x02, 0x61, 0x73, 0x61, 0x72, 0x00, 0x00,
	0x00, 0x06, 0x4d, 0x6f, 0x67, 0x77, 0x61, 0x69, 0x61, 0x73, 0x64, 0x6e,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x61, 0x73, 0x74, 0x6e, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x01, 0x6d, 0x69, 0x69, 0x64, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x11, 0x3e, 0x6d, 0x69, 0x6e, 0x6d, 0x00, 0x00, 0x00, 0x09,
	0x41, 0x75, 0x74, 0x6f, 0x20, 0x52, 0x6f, 0x63, 0x6b, 0x6d, 0x70, 0x65,
	0x72, 0x00, 0x00, 0x00, 0x08, 0xe6, 0xcc, 0x5e, 0x6f, 0x61, 0xc9, 0x12,
	0x23, 0x61, 0x73, 0x61, 0x69, 0x00, 0x00, 0x00, 0x08, 0x51, 0xe5, 0x26,
	0xcf, 0xc7, 0xcd, 0x8f, 0x53, 0x61, 0x73, 0x72, 0x69, 0x00, 0x00, 0x00,
	0x08, 0xd2, 0xc1, 0x7b, 0x9c, 0x90, 0xb1, 0xf2, 0x9a
	},
	189,
	"daap.databasesongs:\n"
	"  dmap.status: 200\n"
	"  dmap.updatetype: 0\n"
	"  dmap.specifiedtotalcount: 1\n"
	"  dmap.returnedcount: 1\n"
	"  dmap.listing:\n"
	"    dmap.listingitem:\n"
	"      dmap.itemkind: 2\n"
	"      daap.songartist: Mogwai\n"
	"      daap.songdiscnumber: 1\n"
	"      daap.songtracknumber: 1\n"
	"      dmap.itemid: 4414\n"
	"      dmap.itemname: Auto Rock\n"
	"      dmap.persistentid: 16630771356447347235\n"
	"      daap.songalbumid: 5901165560591126355\n"
	"      daap.songartistid: 15186555330842718874\n"
},
{
	"Database songs response with date",
	{
	0x61, 0x64, 0x62, 0x73, 0x00, 0x00, 0x00, 0x5e, 0x6d, 0x73, 0x74, 0x74,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x6d, 0x75, 0x74, 0x79,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x6d, 0x74, 0x63, 0x6f, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x01, 0x6d, 0x72, 0x63, 0x6f, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x01, 0x6d, 0x6c, 0x63, 0x6c, 0x00, 0x00, 0x00,
	0x29, 0x6d, 0x6c, 0x69, 0x74, 0x00, 0x00, 0x00, 0x21, 0x6d, 0x69, 0x6b,
	0x64, 0x00, 0x00, 0x00, 0x01, 0x02, 0x61, 0x73, 0x64, 0x61, 0x00, 0x00,
	0x00, 0x04, 0x45, 0x02, 0x1f, 0x23, 0x6d, 0x69, 0x69, 0x64, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x07, 0x6f
	},
	102,
	"daap.databasesongs:\n"
	"  dmap.status: 200\n"
	"  dmap.updatetype: 0\n"
	"  dmap.specifiedtotalcount: 1\n"
	"  dmap.returnedcount: 1\n"
	"  dmap.listing:\n"
	"    dmap.listingitem:\n"
	"      dmap.itemkind: 2\n"
	"      daap.songdateadded: 2006-09-09 01:55:47 +0000\n"
	"      dmap.itemid: 1903\n"
},
{
	"Database songs response with relative volume",
	{
	0x61, 0x64, 0x62, 0x73, 0x00, 0x00, 0x00, 0x4f, 0x6d, 0x73, 0x74, 0x74,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x6d, 0x75, 0x74, 0x79,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x6d, 0x74, 0x63, 0x6f, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x01, 0x6d, 0x72, 0x63, 0x6f, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x01, 0x6d, 0x6c, 0x63, 0x6c, 0x00, 0x00, 0x00,
	0x1a, 0x6d, 0x6c, 0x69, 0x74, 0x00, 0x00, 0x00, 0x12, 0x6d, 0x69, 0x6b,
	0x64, 0x00, 0x00, 0x00, 0x01, 0x02, 0x61, 0x73, 0x72, 0x76, 0x00, 0x00,
	0x00, 0x01, 0xc4
	},
	87,
	"daap.databasesongs:\n"
	"  dmap.status: 200\n"
	"  dmap.updatetype: 0\n"
	"  dmap.specifiedtotalcount: 1\n"
	"  dmap.returnedcount: 1\n"
	"  dmap.listing:\n"
	"    dmap.listingitem:\n"
	"      dmap.itemkind: 2\n"
	"      daap.songrelativevolume: -60\n"
}
};

void indent() {
	strcat(prefix, "  ");
}

void outdent() {
	size_t len = strlen(prefix);
	if (len >= 2) {
		prefix[len - 2] = '\0';
	}
}

void append(const char* line, ...) {
	va_list args;
	va_start(args, line);

	strcat(&output[outpos], prefix);
	outpos += strlen(prefix);
	outpos += vsprintf(&output[outpos], line, args);
	strcat(&output[outpos], "\n");
	outpos++;

	va_end(args);
}

void on_dict_start(void *ctx, const char *code, const char *name) {
	append("%s:", name);
	indent();
}

void on_dict_end(void *ctx, const char *code, const char *name) {
	outdent();
}

void on_int32(void *ctx, const char *code, const char *name, int32_t value) {
	append("%s: %d", name, value);
}

void on_int64(void *ctx, const char *code, const char *name, int64_t value) {
	append("%s: %lld", name, value);
}

void on_uint32(void *ctx, const char *code, const char *name, uint32_t value) {
	append("%s: %u", name, value);
}

void on_uint64(void *ctx, const char *code, const char *name, uint64_t value) {
	append("%s: %llu", name, value);
}

void on_date(void *ctx, const char *code, const char *name, uint32_t value) {
	char buf[32];
	time_t timeval = value;
	struct tm* timestruct = gmtime(&timeval);
	strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S +0000", timestruct);
	append("%s: %s", name, buf);
}

void on_string(void *ctx, const char *code, const char *name, const char *buf, size_t len) {
	char *str = (char *)malloc(len + 1);
	strncpy(str, buf, len);
	str[len] = '\0';
	append("%s: %s", name, str);
	free(str);
}

void on_data(void *ctx, const char *code, const char *name, const char *buf, size_t len) {
	char *str = malloc((len * 3) + 1);
	size_t i;
	char *p = str;
	for (i = 0; i < len; i++) {
		if (i > 0)
			*p++ = ' ';

		*p++ = hexchars[buf[i] >> 4];
		*p++ = hexchars[buf[i] & 0x0f];
	}
	*p = '\0';
	append("%s: <%s>", name, str);
	free(str);
}

int main() {
	dmap_settings settings = {
		on_dict_start,
		on_dict_end,
		on_int32,
		on_int64,
		on_uint32,
		on_uint64,
		on_date,
		on_string,
		on_data,
		NULL
	};

	int i;
	int count = sizeof(tests) / sizeof(test);
	int failcount = 0;
	int result;

	assert(dmap_version() > 1000000);
	assert(strlen(dmap_version_string()) > 0);

	assert(dmap_name_from_code(NULL) == NULL);
	assert(dmap_name_from_code("") == NULL);
	assert(strcmp(dmap_name_from_code("minm"), "dmap.itemname") == 0);

	assert(dmap_parse(NULL, NULL, 0) == -1);
	assert(dmap_parse(&settings, NULL, 0) == -1);

	for (i = 0; i < count; i++) {
		output[0] = '\0';
		outpos = 0;
		prefix[0] = '\0';
		result = dmap_parse(&settings, tests[i].msg, tests[i].msglen);
		if (tests[i].expected != NULL) {
			if (result != 0) {
				failcount++;
				printf("Failed test: %s returned error response\n",
						tests[i].name);
			} else if (strcmp(output, tests[i].expected) != 0) {
				failcount++;
				printf("Failed test: %s\nExpected:\n%sActual:\n%s\n",
						tests[i].name,
						tests[i].expected,
						output);
			}
		} else if (result != -1) {
			failcount++;
			printf("Failed test: %s, should have errored\n",
						tests[i].name);
		}
	}

	printf("%d tests passed", count - failcount);
	if (failcount > 0)
		printf(", %d failed", failcount);
	printf("\n");

	return failcount ? 1 : 0;
}
